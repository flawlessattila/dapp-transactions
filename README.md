[DEMO](https://dapp-transactions.vercel.app/)

<!-- Выполнил задание со звездочкой -->

Приложение работает отлично. Постарался использовать минимум библиотек.
В итоге из библиотек вышли только сам реакт и crypto-js для получения хэша пароля к API. Для перехвата запросов написал свою мини-обертку fetch.
 

## Состояние

Для управления состоянием загрузки товаров и фильтрации я выбрал useContext и useReducer. Так как, пробрасывание состояния пропсами крепко привязало бы их к родителю, а redux был бы избыточен.

## Оптимизация

Я специально предоставил два сценария загрузки товаров.

- Когда один из фильтров активен загружаются все id товаров без limit и offset. И пагинация работает на стороне клиента. Это сокращает кол-во запросов, но использует гораздо больше ресурсов клиентского устройства. При объеме до 10 000 товаров это еще допустимо.
- Без фильтрации получаю get_ids и get_items постранично. 2 запроса каждую страницу - много для такого простой задачи, тем более возврастает нагрузка на сервер. Но клиентское приложение отдыхает по сравнению с 1 вариантом.

Если представить такую задачу на реальном проекте и возможности оптимизировать(объединить) эти 2 запроса(get_ids и get_items) на стороне сервера нет, то выбрать оптимальный из этих вариантов поможет тестирование производительности, определение объема данных и сравнение нагрузки на сервер.


## Пагинация

Без активных фильтров переключение страницы вызывает запрос к API action: "get_ids" в тулбаре. Результат get_ids вызывает запрос к API action: "get_items" в компоненте ProductsList. ProductsList зависит только от массива id товаров. Это позволяет контролировать выдачу товаров тулбаре. И с таким особенным api, когда у нас нет пагинации запроса action: "filters", это хорошее решение.


## Фильтрация

Как только одно из полей фильтра изменились в активное состояние (!= ""), он устанавливается в глобальном состоянии, остальные параметры фильтра устанавливаются в исходное положение "" тк апи не поддерживает фильтрацию с несколькими полями одновременно. Делается запрос к action: "filters" с соответствующим фильтром и сохраняется в локальном стейте тулбара. При смене страницы, id товаров будут идти не с сервера а с этого локального стейта.


## Список брендов для фильтра

Запрос  action: "get_fields" я использовал только для того чтобы получить список брендов для селектора из тулбара. Остальные сценарии применения этого запроса я не нашел.


## По остальному

Реализована простейшая версия axios для перехватки запросов src/utils/customFetch.js
Так же для дебаунса и предотвращения перерисовки старыми рандерами новых используется хук useDebounce и AbortController в интерцепторе useValantisService